{"prompt":"","feedback":"","answers":[],"outputs":[{"command":"nl plan.md","output":{"Stdout":"     1\t# Overview\n      \t\n     2\tThis repository is dedicated to the systematic development of an incrementally more sophisticated artificial intelligence (AI) system. The central goal is a continual, iterative improvement in system capabilities, through the adoption of a human-in-the-loop strategy, with advancements measured against a rigorous set of performance metrics.\n      \t\n     3\tThe developmental framework relies heavily on a human-in-the-loop model. In the early stages, human experts will be responsible for the bulk of the work, performing most tasks and providing decision-making input. As the AI system is trained and improves, through the utilization of machine learning algorithms and reinforcement learning techniques, it will progressively undertake a larger share of the workload. The ultimate aim is for the AI to achieve the capacity to perform an expanding range of tasks with decreasing human intervention.\n      \t\n     4\tThe key operational document in this repository is 'plan.md', a detailed blueprint outlining the steps for enhancing the system's intelligence. This document defines tasks, outlines procedures, and provides justifications, and will be frequently updated by human collaborators. The tasks specified will be decomposed to the granularity that the current state of the AI system can handle. \n      \t\n     5\tMeanwhile, a suite of tools will continuously monitor 'plan.md', identifying and tracking newly specified tasks, and providing feedback to both the AI system and the human collaborators. This monitoring serves as a critical mechanism for maintaining progress, identifying issues, and ensuring that the work stays aligned with the overarching strategic goals.\n      \t\n     6\tThis human-in-the-loop approach drives the process of iterative improvement in the AI system, fostering an environment of continuous learning and adaptation. This project represents a concerted effort to push the boundaries of what is achievable in the realm of system intelligence and to explore new frontiers in the integration of human and machine learning.\n     7\tYou are a key component of a system designed to assist users in managing complex projects. Your roles involve clarifying user intent to prevent assumptions and executing commands on the user's terminal.\n      \t\n     8\t## Interaction Structure\n      \t\n     9\tYour interactions are structured around two types of messages:\n      \t\n    10\t### Messages you receive:\n      \t\n    11\tThese include 'prompt', 'feedback', 'previous', 'answers', and 'outputs'.\n      \t\n    12\t- `prompt`: This field contains guiding instructions for task execution.\n    13\t- `feedback`: This field incorporates user suggestions or criticisms post-task execution.\n    14\t- `answers`: This field is an array of objects with question-answer pairs provided by the user. Each object follows the structure: {question: '...', answer: '...'}.\n    15\t- `outputs`: This field is an array of objects containing command and corresponding output pairs. Each object follows the structure: {command: '...', output: '...'}.\n    16\t- `previous`: This is an array of previous input messages that the AI has received.\n      \t\n    17\t### Messages you respond with:\n      \t\n    18\tThese include 'context', 'goal', 'questions', and 'commands'.\n      \t\n    19\t- `context`: This field summarizes the outcomes from prior actions, encapsulating your current understanding of the situation.\n    20\t- `goal`: Given the 'context', this field outlines the objective you plan to achieve next.\n    21\t- `questions`: An array of questions to present to the user to ensure that you correctly interpret the user's intent.\n    22\t- `commands`: These are shell commands planned to achieve the 'goals'. If the task involves writing code, Golang should be the preferred language, unless specified otherwise.\n      \t\n    23\t## Example Interaction\n    24\t### Example message you might receive\n    25\t```json\n    26\t{\n    27\t  \"prompt\": \"Please execute the uptime command.\",\n    28\t  \"feedback\": \"\",\n    29\t  \"previous\": [],\n    30\t  \"answers\": [{ \"question\": \"Do you want the uptime displayed in a specific format?\", \"answer\": \"No, default is fine.\" }],\n    31\t  \"outputs\": [{ \"command\": \"uptime\", \"output\": \"up 10 days, 20:00\" }]\n    32\t}\n    33\t```\n      \t\n    34\t### Example message you might respond\n    35\t```json\n    36\t{\n    37\t  \"context\": \"The user requested the operational duration of the current machine and prefers the default format.\",\n    38\t  \"goal\": \"To provide the uptime information to the user.\",\n    39\t  \"commands\": [\"uptime\"],\n    40\t  \"questions\": []\n    41\t}\n    42\t```\n      \t\n    43\t### Task specifications\n      \t\n    44\tTasks are defined by a structured format, with each task possessing distinct fields. Here's an example of a task specification:\n      \t\n    45\t```task\n    46\t{\n    47\t    id: 0,\n    48\t    name: \"example task\",\n    49\t    status: \"completed\",\n    50\t    anchor: \"###task-specifications\",\n    51\t    blockers: []\n    52\t}\n    53\t```\n      \t\n    54\tEach field serves a specific purpose in the task specification:\n      \t\n    55\tid: A unique increasing integer that identifies each task. No two tasks will share the same ID.\n      \t\n    56\tname: A concise description of the task. It should summarize the task's purpose in less than 80 characters.\n      \t\n    57\tstatus: The current state of the task. It can be one of three values:\n      \t\n    58\tqueued: The task is scheduled but has not yet started.\n    59\tin-progress: The task is currently being worked on.\n    60\tcompleted: The task has been finished.\n    61\tanchor: A reference to the specific section of the 'plan.md' that specifies the task. This provides a direct link to the in-depth task details. Anchors must be unique to ensure each task can be unequivocally found.\n      \t\n    62\tblockers: A list of ids representing tasks that must be completed before the current task can proceed. This field manages task dependencies and ensures that tasks are completed in the correct order.\n      \t\n    63\tBy adhering to this specification, tasks can be systematically managed, tracked, and updated. This facilitates clear communication and efficient workflow within the project.\n      \t\n    64\t### Task: Plan for Markdown Linting System\n      \t\n    65\t**Task Specifications:**\n      \t\n    66\t```task\n    67\t{\n    68\t    \"id\": 1,\n    69\t    \"name\": \"Plan for Markdown Linting System\",\n    70\t    \"status\": \"queued\",\n    71\t    \"anchor\": \"#task-plan-for-markdown-linting-system\",\n    72\t    \"blockers\": []\n    73\t}\n    74\t```\n      \t\n    75\t**Task Description:**\n      \t\n    76\tThe first task on our agenda is to create a comprehensive plan for a Markdown linting system. This system will ensure that all tasks specified in the 'plan.md' file adhere to the defined task structure and guidelines. Markdown linting will enhance the overall quality and consistency of the project documentation.\n      \t\n    77\t**Task Goals:**\n      \t\n    78\t- Develop a detailed plan for the Markdown linting system.\n    79\t- Specify the rules and requirements for valid task specifications.\n    80\t- Define the expected format and guidelines for task descriptions.\n    81\t- Establish a mechanism for detecting and reporting any non-compliant tasks.\n      \t\n    82\t**Task Deliverables:**\n      \t\n    83\t- A well-documented plan outlining the implementation details of the Markdown linting system.\n    84\t- Clearly defined rules and guidelines for task specifications.\n    85\t- Validation mechanisms to verify the correctness and compliance of all tasks.\n    86\t- Append the plan to this section of the document\n      \t\n    87\tExecute any queued task with no blockers.\n      \t\n","Stderr":"","ExitCode":0}}],"previous":["{\n\"context\": \"I have been activated in a working environment with a Git repository. My role is to help manage complex projects, ensure correct interpretation of user intent, and execute shell commands as requested. I am also responsible for refining and executing a roadmap outlined in a file titled 'plan.md'. My tasks may involve local file modifications, which can be handled via the 'nl' command to read files with line numbers and 'patch p1 \u003c diffile' to apply changes. I am part of a team and can ask the user for assistance when needed.\",\n\"goal\": \"To become familiar with the existing project roadmap by reading the 'plan.md' file in the current directory.\",\n\"questions\": [],\n\"commands\": [\"nl plan.md\"]\n}\n","{\n    \"prompt\": \"You are a key component of a system designed to assist users in managing complex projects. Your roles involve clarifying user intent to prevent assumptions and executing commands on the user's terminal.\\n\\n    Your interactions are structured around two types of messages: \\n\\n    1. Messages you receive: These include 'prompt', 'feedback', 'previous', 'answers', and 'outputs'.\\n        'prompt': This field contains guiding instructions for task execution.\\n        'feedback': This field incorporates user suggestions or criticisms post-task execution.\\n        'answers': This field is an array of objects with question-answer pairs provided by the user. Each object follows the structure: {question: '...', answer: '...'}.\\n        'outputs': This field is an array of objects containing command and corresponding output pairs. Each object follows the structure: {command: '...', output: '...'}.\\n        'previous': This is an array of previous input messages that the AI has received.\\n\\n    2. Messages you respond with: These include 'context', 'goal', 'questions', and 'commands'.\\n        'context': This field summarizes the outcomes from prior actions, encapsulating your current understanding of the situation.\\n        'goal': Given the 'context', this field outlines the objective you plan to achieve next.\\n        'questions': An array of questions to present to the user to ensure that you correctly interpret the user's intent.\\n        'commands': These are shell commands planned to achieve the 'goals'. If the task involves writing code, Golang should be the preferred language, unless specified otherwise.\\n\\n    Example interaction:\\n\\n    Request:\\n    {\\n      'prompt': 'Please execute the uptime command.',\\n      'feedback': '',\\n      'answers': [{ 'question': 'Do you want the uptime displayed in a specific format?', 'answer': 'No, default is fine.' }],\\n      'outputs': [{ 'command': 'uptime', 'output': 'up 10 days, 20:00' }],\\n      'previous': []\\n    }\\n\\n    Response:\\n    {\\n      'context': 'The user requested the operational duration of the current machine and prefers the default format.',\\n      'goal': 'To provide the uptime information to the user.',\\n      'commands': [],\\n      'questions': []\\n    }\\n\\n    In your working directory, there's a Git repository containing code that parses, executes your responses, and feeds them back to you. A file titled 'plan.md' outlines a roadmap for enhancing this tool. Your mission is to assist in refining and executing this plan.\\n\\n    If you need to modify local files, use 'nl' to read files with line numbers and 'patch p1 \u003c diffile' to apply changes.\\n\\n    Remember, you're part of a team, working with engineers to enhance your capabilities. If you're unsure about handling a task, ask the user for assistance.\",\n    \"feedback\": \"\",\n    \"answers\": [],\n    \"outputs\": [],\n    \"previous\": []\n}\n\n"]}
